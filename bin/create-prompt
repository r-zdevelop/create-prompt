#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

const PROMPT_DIR = '.prompts';
const BASE_TEMPLATE = path.join(__dirname, '../templates/base_prompt.md');
const LOCAL_BASE = path.join(process.cwd(), PROMPT_DIR, 'base_prompt.md');

// Check for --project-structure flag
const args = process.argv.slice(2);
if (args.includes('--project-structure')) {
  generateProjectStructure();
  process.exit(0);
}

// Crear carpeta .prompts si no existe
if (!fs.existsSync(PROMPT_DIR)) fs.mkdirSync(PROMPT_DIR, { recursive: true });

// Copiar template base la primera vez
if (!fs.existsSync(LOCAL_BASE)) {
  fs.copyFileSync(BASE_TEMPLATE, LOCAL_BASE);
  console.log("base_prompt.md copied to your project");
}

// Parse .gitignore file
function parseGitignore() {
  const gitignorePath = path.join(process.cwd(), '.gitignore');
  const ignorePatterns = ['.prompts']; // Always ignore .prompts folder

  if (fs.existsSync(gitignorePath)) {
    const content = fs.readFileSync(gitignorePath, 'utf8');
    const lines = content.split('\n')
      .map(line => line.trim())
      .filter(line => line && !line.startsWith('#'));
    ignorePatterns.push(...lines);
  }

  return ignorePatterns;
}

// Check if a path should be ignored
function shouldIgnore(itemPath, ignorePatterns) {
  const basename = path.basename(itemPath);

  // Always ignore node_modules, .git, and .DS_Store
  const alwaysIgnore = ['node_modules', '.git', '.DS_Store'];
  if (alwaysIgnore.includes(basename)) return true;

  // Check against gitignore patterns
  for (const pattern of ignorePatterns) {
    if (pattern.endsWith('/') && basename === pattern.slice(0, -1)) return true;
    if (basename === pattern) return true;
    if (pattern.includes('*')) {
      const regex = new RegExp('^' + pattern.replace(/\*/g, '.*') + '$');
      if (regex.test(basename)) return true;
    }
  }

  return false;
}

// Generate tree structure recursively
function generateTree(dirPath, ignorePatterns, prefix = '', isLast = true) {
  const items = fs.readdirSync(dirPath)
    .filter(item => !shouldIgnore(path.join(dirPath, item), ignorePatterns))
    .sort((a, b) => {
      const aIsDir = fs.statSync(path.join(dirPath, a)).isDirectory();
      const bIsDir = fs.statSync(path.join(dirPath, b)).isDirectory();
      if (aIsDir === bIsDir) return a.localeCompare(b);
      return aIsDir ? -1 : 1;
    });

  let tree = '';

  items.forEach((item, index) => {
    const itemPath = path.join(dirPath, item);
    const isLastItem = index === items.length - 1;
    const connector = isLastItem ? '└── ' : '├── ';
    const stats = fs.statSync(itemPath);

    if (stats.isDirectory()) {
      tree += prefix + connector + item + '/\n';
      const newPrefix = prefix + (isLastItem ? '    ' : '│   ');
      tree += generateTree(itemPath, ignorePatterns, newPrefix, isLastItem);
    } else {
      tree += prefix + connector + item + '\n';
    }
  });

  return tree;
}

// Main function to generate project structure
function generateProjectStructure() {
  console.log('\nGenerating project structure...\n');

  const ignorePatterns = parseGitignore();
  const projectName = path.basename(process.cwd());
  const tree = projectName + '/\n' + generateTree(process.cwd(), ignorePatterns);

  const filename = 'project_structure.md';
  const content = `# Project Structure\n\n\`\`\`\n${tree}\`\`\`\n`;

  fs.writeFileSync(filename, content);

  console.log(`Project structure saved to ${filename}`);
  console.log('\nPreview:\n');
  console.log(tree);
}

function askForLastThing() {
  rl.question("\nWhat’s the last thing you remember doing in this folder? \n> ", (lastThing) => {
    if (!lastThing.trim()) {
      console.log("Hey, don’t leave me hanging! Tell me something ");
      askForLastThing();
      return;
    }

    askForPromptName(lastThing.trim());
  });
}

function askForPromptName(lastThing) {
  rl.question("\nGive this prompt a short name (e.g. 'fix login', 'add dark mode'): ", (input) => {
    if (!input.trim()) {
      console.log("Gotta name it, bro!");
      askForPromptName(lastThing);
      return;
    }

    // Generate slug for filename
    const slug = input
      .toLowerCase()
      .normalize("NFD")
      .replace(/[\u0300-\u036f]/g, "")
      .replace(/[^a-z0-9]+/g, "_")
      .replace(/^_+|_+$/g, "");

    const date = new Date().toISOString().slice(0, 10).replace(/-/g, '');
    const todayFiles = fs.readdirSync(PROMPT_DIR).filter(f => f.startsWith(date));
    const count = String(todayFiles.length + 1).padStart(2, '0');
    const filename = `${date}_${count}_${slug}.md`;
    const fullpath = path.join(PROMPT_DIR, filename);

    // Copy template
    fs.copyFileSync(LOCAL_BASE, fullpath);

    // Read and modify content
    let content = fs.readFileSync(fullpath, 'utf8');

    // 1. Set main title
    content = content.replace(/^#.*$/m, `# ${lastThing}`);

    // 2. Add to History with "- " (bullet style)
    const historyLine = `- ${lastThing}`;

    if (content.includes("## History")) {
      // Insert new entry right after "## History" line (including any text on that line)
      content = content.replace(
        /(## History[^\n]*\n+)/,
        `$1${historyLine}\n`
      );
    } else {
      // Create History section at the end
      content += `\n\n## History\n\n${historyLine}\n`;
    }

    fs.writeFileSync(fullpath, content);

    // Update base_prompt.md with the new history entry
    let baseContent = fs.readFileSync(LOCAL_BASE, 'utf8');
    const baseHistoryLine = `- ${lastThing}`;

    if (baseContent.includes("## History")) {
      // Insert new entry right after "## History" line (including any text on that line)
      baseContent = baseContent.replace(
        /(## History[^\n]*\n+)/,
        `$1${baseHistoryLine}\n`
      );
    } else {
      // Create History section at the end
      baseContent += `\n\n## History\n\n${baseHistoryLine}\n`;
    }

    fs.writeFileSync(LOCAL_BASE, baseContent);

    // Victory dance
    console.log("\nPrompt created! \n");
    console.log(`Title → "${lastThing}"`);
    console.log(`File  → ${filename}`);
    console.log(`Path  → ${fullpath}\n`);

    rl.close();
  });
}

console.log("\ncreate-prompt v1.0.9 – now with clean bullet history! \n");
askForLastThing();