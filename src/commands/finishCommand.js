const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { createInterface } = require('readline');
const config = require('../config');

/**
 * Ask user a question and return the answer
 * @param {readline.Interface} rl - Readline interface
 * @param {string} question - Question to ask
 * @param {boolean} required - Whether the answer is required
 * @returns {Promise<string>} User's answer
 */
function askQuestion(rl, question, required = false) {
  return new Promise((resolve) => {
    const ask = () => {
      rl.question(question, (answer) => {
        if (required && !answer.trim()) {
          console.log("This field is required. Please provide an answer.");
          ask();
        } else {
          resolve(answer.trim());
        }
      });
    };
    ask();
  });
}

/**
 * Get git status output
 * @returns {string} Git status output
 */
function getGitStatus() {
  try {
    return execSync('git status', { encoding: 'utf8' });
  } catch (error) {
    console.error('Error running git status:', error.message);
    return '';
  }
}

/**
 * Perform git commit
 * @param {string} message - Commit message
 * @returns {boolean} Success status
 */
function performGitCommit(message) {
  try {
    // Add all changes
    execSync('git add .', { encoding: 'utf8' });

    // Commit with message
    execSync(`git commit -m "${message.replace(/"/g, '\\"')}"`, { encoding: 'utf8' });

    return true;
  } catch (error) {
    console.error('Error performing git commit:', error.message);
    return false;
  }
}

/**
 * Create or replace latest_commit.md file
 * @param {string} whatUserDid - What the user did in the directory
 * @param {string} changesDescription - Description of changes
 * @param {string} gitStatus - Git status output
 */
function createLatestCommitFile(whatUserDid, changesDescription, gitStatus) {
  const promptsDir = path.join(process.cwd(), config.PROMPT_DIR);

  // Ensure .prompts directory exists
  if (!fs.existsSync(promptsDir)) {
    fs.mkdirSync(promptsDir, { recursive: true });
  }

  const latestCommitPath = path.join(promptsDir, 'latest_commit.md');
  const timestamp = new Date().toISOString();

  const content = `# Latest Commit

**Date:** ${timestamp}

## What I Did
${whatUserDid}

## Changes Description
${changesDescription}

## Git Status Before Commit
\`\`\`
${gitStatus}
\`\`\`

---
*Generated by create-prompt finish command*
`;

  fs.writeFileSync(latestCommitPath, content);
  console.log(`\n‚úÖ Created/updated: ${latestCommitPath}`);
}

/**
 * Update base_prompt.md with latest commit section and history table
 * @param {string} whatUserDid - What the user did in the directory
 * @param {string} changesDescription - Description of changes
 */
function updateBasePromptWithCommit(whatUserDid, changesDescription) {
  const basePromptPath = config.LOCAL_BASE_PATH;

  // Check if base_prompt.md exists
  if (!fs.existsSync(basePromptPath)) {
    console.log('‚ö†Ô∏è  base_prompt.md not found, skipping update');
    return;
  }

  let content = fs.readFileSync(basePromptPath, 'utf8');
  const timestamp = new Date().toISOString();
  const commitSummary = changesDescription || whatUserDid;

  // Create the latest commit section
  const latestCommitSection = `## Latest commit

**Date:** ${timestamp}
**Summary:** ${commitSummary}

---

`;

  // Check if "## Latest commit" section already exists
  const latestCommitRegex = /## Latest commit[\s\S]*?(?=\n## )/;

  if (latestCommitRegex.test(content)) {
    // Replace existing "## Latest commit" section
    content = content.replace(latestCommitRegex, latestCommitSection);
  } else {
    // Insert new "## Latest commit" section after "## History" and before "## Task"
    const historyTaskRegex = /(## History[\s\S]*?)(\n---\n+)(## Task)/;

    if (historyTaskRegex.test(content)) {
      content = content.replace(historyTaskRegex, `$1$2${latestCommitSection}$3`);
    } else {
      // If pattern not found, try to insert before ## Task
      const taskRegex = /(## Task)/;
      if (taskRegex.test(content)) {
        content = content.replace(taskRegex, `${latestCommitSection}$1`);
      } else {
        // As last resort, append at the end
        content += `\n${latestCommitSection}`;
      }
    }
  }

  // Add entry to History section
  const historyEntry = `- ${commitSummary}`;

  // Check if History section exists and is in bullet list format
  const historyBulletRegex = /(## History\n\n)((?:- .*\n)*)/;

  if (historyBulletRegex.test(content)) {
    // Add to existing bullet list at the top (most recent first)
    content = content.replace(historyBulletRegex, `$1${historyEntry}\n$2`);
  } else {
    // Check if History section exists with table format or other format
    const historyHeaderRegex = /(## History\n\n)/;

    if (historyHeaderRegex.test(content)) {
      // Add bullet list entry after History header
      content = content.replace(historyHeaderRegex, `$1${historyEntry}\n`);
    }
  }

  fs.writeFileSync(basePromptPath, content);
  console.log(`‚úÖ Updated: ${basePromptPath}`);
}

/**
 * Finish command - handles the complete workflow
 */
async function finishCommand() {
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout
  });

  try {
    console.log('\nüèÅ Finishing up your work...\n');

    // Step 1: Ask what the user did (mandatory)
    const whatUserDid = await askQuestion(
      rl,
      "What did you do in this directory? (required)\n> ",
      true
    );

    // Step 2: Run git status
    console.log('\nüìä Running git status...\n');
    const gitStatus = getGitStatus();
    console.log(gitStatus);

    // Step 3: Ask for changes description
    const changesDescription = await askQuestion(
      rl,
      "\nDescribe the changes you performed:\n> ",
      false
    );

    // Step 4: Create or replace latest_commit.md
    createLatestCommitFile(whatUserDid, changesDescription, gitStatus);

    // Step 5: Update base_prompt.md with latest commit section
    updateBasePromptWithCommit(whatUserDid, changesDescription);

    // Step 6: Perform the commit
    console.log('\nüíæ Creating git commit...');
    const commitMessage = changesDescription || whatUserDid;
    const success = performGitCommit(commitMessage);

    if (success) {
      console.log('‚úÖ Commit created successfully!\n');
    } else {
      console.log('‚ùå Failed to create commit. Please check the errors above.\n');
    }

  } catch (error) {
    console.error('Error during finish command:', error.message);
  } finally {
    rl.close();
  }
}

module.exports = finishCommand;
