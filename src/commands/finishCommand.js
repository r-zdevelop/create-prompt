const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { createInterface } = require('readline');
const config = require('../config');

/**
 * Ask user a question and return the answer
 * @param {readline.Interface} rl - Readline interface
 * @param {string} question - Question to ask
 * @param {boolean} required - Whether the answer is required
 * @returns {Promise<string>} User's answer
 */
function askQuestion(rl, question, required = false) {
  return new Promise((resolve) => {
    const ask = () => {
      rl.question(question, (answer) => {
        if (required && !answer.trim()) {
          console.log("This field is required. Please provide an answer.");
          ask();
        } else {
          resolve(answer.trim());
        }
      });
    };
    ask();
  });
}

/**
 * Get list of modified/added/deleted files from git status
 * @returns {Array} Array of file objects {path, status}
 */
function getModifiedFiles() {
  try {
    const output = execSync('git status --porcelain', { encoding: 'utf8' });
    const files = [];

    output.split('\n').forEach(line => {
      if (!line.trim()) return;

      const statusCode = line.substring(0, 2).trim();
      const filePath = line.substring(3).trim();

      let status = 'Modified';
      if (statusCode === 'A' || statusCode === '??') status = 'Added';
      else if (statusCode === 'D') status = 'Deleted';
      else if (statusCode === 'M') status = 'Modified';
      else if (statusCode === 'R') status = 'Renamed';

      files.push({ path: filePath, status });
    });

    return files;
  } catch (error) {
    return [];
  }
}

/**
 * Ask user for changes description for each file
 * @param {readline.Interface} rl - Readline interface
 * @param {Array} files - Array of file objects
 * @returns {Promise<string>} Formatted changes table
 */
async function askForChangesTable(rl, files) {
  if (files.length === 0) {
    console.log("\nNo files detected in git status.");
    return '';
  }

  console.log("\nDescribe changes for each file (press Enter 3 times to finish):");
  console.log("Tip: Use ‚Ä¢ for bullet points, <br> for line breaks\n");

  const tableRows = [];
  let emptyCount = 0;

  for (const file of files) {
    const description = await askQuestion(
      rl,
      `What did you do in "${file.path}"? (${file.status}) \n> `,
      false
    );

    if (!description) {
      emptyCount++;
      if (emptyCount >= 3) {
        console.log("Finishing table input...");
        break;
      }
      // Add file to table with default description
      tableRows.push({
        file: `**${file.path}**`,
        type: file.status,
        changes: 'No description provided'
      });
    } else {
      emptyCount = 0;
      tableRows.push({
        file: `**${file.path}**`,
        type: file.status,
        changes: description
      });
    }
  }

  if (tableRows.length === 0) {
    return '';
  }

  // Build the markdown table
  let table = '| File | Type | Changes |\n';
  table += '|------|------|---------|';

  tableRows.forEach(row => {
    table += `\n| ${row.file} | ${row.type} | ${row.changes} |`;
  });

  return table;
}

/**
 * Get git status output
 * @returns {string} Git status output
 */
function getGitStatus() {
  try {
    return execSync('git status', { encoding: 'utf8' });
  } catch (error) {
    console.error('Error running git status:', error.message);
    return '';
  }
}

/**
 * Perform git commit
 * @param {string} message - Commit message
 * @returns {boolean} Success status
 */
function performGitCommit(message) {
  try {
    // Add all changes
    execSync('git add .', { encoding: 'utf8' });

    // Commit with message
    execSync(`git commit -m "${message.replace(/"/g, '\\"')}"`, { encoding: 'utf8' });

    return true;
  } catch (error) {
    console.error('Error performing git commit:', error.message);
    return false;
  }
}

/**
 * Create or replace latest_commit.md file
 * @param {string} whatUserDid - What the user did in the directory
 * @param {string} changesTable - Changes table
 * @param {string} gitStatus - Git status output
 */
function createLatestCommitFile(whatUserDid, changesTable, gitStatus) {
  const promptsDir = path.join(process.cwd(), config.PROMPT_DIR);

  // Ensure .prompts directory exists
  if (!fs.existsSync(promptsDir)) {
    fs.mkdirSync(promptsDir, { recursive: true });
  }

  const latestCommitPath = path.join(promptsDir, 'latest_commit.md');
  const timestamp = new Date().toISOString();

  let content = `# ${whatUserDid}

**Date:** ${timestamp}
`;

  // Add Changes section if table is provided
  if (changesTable && changesTable.trim()) {
    content += `
## Changes

${changesTable}
`;
  }

  content += `
## Git Status Before Commit
\`\`\`
${gitStatus}
\`\`\`

---
*Generated by create-prompt finish command*
`;

  fs.writeFileSync(latestCommitPath, content);
  console.log(`\n‚úÖ Created/updated: ${latestCommitPath}`);
}

/**
 * Update base_prompt.md with latest commit section and history
 * @param {string} whatUserDid - What the user did in the directory
 * @param {string} changesTable - Changes table
 */
function updateBasePromptWithCommit(whatUserDid, changesTable) {
  const basePromptPath = config.LOCAL_BASE_PATH;

  // Check if base_prompt.md exists
  if (!fs.existsSync(basePromptPath)) {
    console.log('‚ö†Ô∏è  base_prompt.md not found, skipping update');
    return;
  }

  let content = fs.readFileSync(basePromptPath, 'utf8');
  const timestamp = new Date().toISOString();

  // Build the latest commit section
  let latestCommitSection = `## Latest Commit

**Date:** ${timestamp}

### The last thing done
${whatUserDid}
`;

  // Add Changes section if table is provided
  if (changesTable && changesTable.trim()) {
    latestCommitSection += `
### Changes

${changesTable}
`;
  }

  latestCommitSection += `
---

`;

  // Check if "## Latest Commit" or "## Latest commit" section already exists
  const latestCommitRegex = /## Latest [Cc]ommit[\s\S]*?(?=\n## )/;

  if (latestCommitRegex.test(content)) {
    // Replace existing "## Latest Commit" section
    content = content.replace(latestCommitRegex, latestCommitSection);
  } else {
    // Insert new "## Latest Commit" section after "## History" and before "## Task"
    const historyTaskRegex = /(## History[\s\S]*?)(\n---\n+)(## Task)/;

    if (historyTaskRegex.test(content)) {
      content = content.replace(historyTaskRegex, `$1$2${latestCommitSection}$3`);
    } else {
      // If pattern not found, try to insert before ## Task
      const taskRegex = /(## Task)/;
      if (taskRegex.test(content)) {
        content = content.replace(taskRegex, `${latestCommitSection}$1`);
      } else {
        // As last resort, append at the end
        content += `\n${latestCommitSection}`;
      }
    }
  }

  // Add entry to History section
  const historyEntry = `- ${whatUserDid}`;

  // Check if History section exists and is in bullet list format
  const historyBulletRegex = /(## History\n\n)((?:- .*\n)*)/;

  if (historyBulletRegex.test(content)) {
    // Add to existing bullet list at the top (most recent first)
    content = content.replace(historyBulletRegex, `$1${historyEntry}\n$2`);
  } else {
    // Check if History section exists with table format or other format
    const historyHeaderRegex = /(## History\n\n)/;

    if (historyHeaderRegex.test(content)) {
      // Add bullet list entry after History header
      content = content.replace(historyHeaderRegex, `$1${historyEntry}\n`);
    }
  }

  fs.writeFileSync(basePromptPath, content);
  console.log(`‚úÖ Updated: ${basePromptPath}`);
}

/**
 * Build full formatted commit message
 * @param {string} whatUserDid - What the user did in the directory
 * @param {string} changesTable - Changes table
 * @returns {string} Formatted commit message
 */
function buildCommitMessage(whatUserDid, changesTable) {
  const timestamp = new Date().toISOString();

  let message = `## ${whatUserDid}

**Date:** ${timestamp}
`;

  // Add Changes section if table is provided
  if (changesTable && changesTable.trim()) {
    message += `
### Changes

${changesTable}
`;
  }

  return message;
}

/**
 * Finish command - handles the complete workflow
 */
async function finishCommand() {
  const rl = createInterface({
    input: process.stdin,
    output: process.stdout
  });

  try {
    console.log('\nüèÅ Finishing up your work...\n');

    // Step 1: Ask what the user did (mandatory)
    const whatUserDid = await askQuestion(
      rl,
      "What did you do in this directory? (required)\n> ",
      true
    );

    // Step 2: Run git status
    console.log('\nüìä Running git status...\n');
    const gitStatus = getGitStatus();
    console.log(gitStatus);

    // Step 3: Get modified files and ask for changes table (optional)
    const modifiedFiles = getModifiedFiles();
    const changesTable = await askForChangesTable(rl, modifiedFiles);

    // Step 4: Create or replace latest_commit.md
    createLatestCommitFile(whatUserDid, changesTable, gitStatus);

    // Step 5: Update base_prompt.md with latest commit section
    updateBasePromptWithCommit(whatUserDid, changesTable);

    // Step 6: Perform the commit with full formatted message
    console.log('\nüíæ Creating git commit...');
    const commitMessage = buildCommitMessage(whatUserDid, changesTable);
    const success = performGitCommit(commitMessage);

    if (success) {
      console.log('‚úÖ Commit created successfully!\n');
    } else {
      console.log('‚ùå Failed to create commit. Please check the errors above.\n');
    }

  } catch (error) {
    console.error('Error during finish command:', error.message);
  } finally {
    rl.close();
  }
}

module.exports = finishCommand;
